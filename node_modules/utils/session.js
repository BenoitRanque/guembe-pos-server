const jwt = require('jsonwebtoken')
const bcrypt = require('bcryptjs')
const { client: sap } = require('utils/sap')
const { UnauthorizedError } = require('utils/errors')

const ONE_MONTH = 30 * 24 * 60 * 60 * 1000
const refreshCookieOptions = {
  httpOnly: true,
  maxAge: ONE_MONTH
}
const ROLE_WHITELIST = [
  'mesero',
  'cajero'
]

async function authenticateEmployee ({ EmployeeID, Password }) {
  const { data: employee } = await sap.get(`/EmployeesInfo(${EmployeeID})`, {
    params: {
      '$expand': `SalesPerson`,
      '$select': `EmployeeID,Active,U_GPOS_Password,SalesPerson/SalesEmployeeCode,SalesPerson/SalesEmployeeName,SalesPerson/Active`
    }
  })

  if (!employee.SalesPerson) {
    throw new Error(`Empleado de venta no configurado`)
  }

  if (employee.SalesPerson.SalesEmployeeCode <= 1) {
    throw new Error(`Empleado de venta invalido: ${employee.SalesPerson.SalesEmployeeCode} ${employee.SalesPerson.SalesEmployeeName}. No se permiten empleados de venta con codigo menor a 2`)
  }
  
  if (employee.Active !== 'tYES') {
    throw new Error(`Empleado inactivo`)
  }
  
  if (employee.SalesPerson.Active !== 'tYES') {
    throw new Error(`Empleado de venta inactivo`)
  }

  if (!employee.U_GPOS_Password) {
    throw new Error(`Para poder inciar session primero establesca contraseña para el usuario ${EmployeeID}`)
  }

  const valid = await bcrypt.compare(Password, employee.U_GPOS_Password)
  if (valid) {
    const { EmployeeID, SalesPerson: { SalesEmployeeCode, SalesEmployeeName } } = employee
    return {
      EmployeeID,
      SalesEmployeeCode,
      SalesEmployeeName
    }
  }

  throw new Error('Error de Autenticación')
}
async function getEmployeeRoles ({ EmployeeID }) {
  const { data: { EmployeeRolesInfoLines: employeeRoles } } = await sap.get(`/EmployeesInfo(${EmployeeID})/EmployeeRolesInfoLines`)
  const { data: { value: roles } } = await sap.get('/EmployeeRolesSetup')

  const Roles = roles
    .filter(({ TypeID, Name }) => employeeRoles.some(({ RoleID }) => RoleID === TypeID))
    .map(({ Name }) => Name.toLowerCase())
    .filter(role => ROLE_WHITELIST.includes(role))
    .concat(['user', 'anonymous'])

  return Roles
}
function encodeRefreshToken(payload) {
  return jwt.sign({ ses: payload }, process.env.AUTH_JWT_SECRET, { expiresIn: '30 days' })
}
function encodeAuthToken(payload) {
  return jwt.sign({ ses: payload }, process.env.AUTH_JWT_SECRET, { expiresIn: '10 minutes' })
}
function decodeToken(token) {
  const { ses } = jwt.verify(token, process.env.AUTH_JWT_SECRET)
  return ses
  // const { ses } = await jwt.verify(token, process.env.AUTH_JWT_SECRET)
  // return ses
}
function parseSession (req) {
  const authorization = req.get('Authorization')

  if (authorization) {
    const token = authorization.replace('Bearer ', '')

    return decodeToken(token)
  }

  return null
}
function requireSession(req) {
  const session = parseSession(req)

  if (!session) {
    throw new UnauthorizedError(`Access denied: Session required`)
  }

  return session
}

module.exports = {
  requireSession,
  parseSession,
  refreshCookieOptions,
  authenticateEmployee,
  getEmployeeRoles,
  encodeAuthToken,
  encodeRefreshToken,
  decodeToken
}
